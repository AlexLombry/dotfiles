#!/usr/bin/env bash
set -euo pipefail

# Full GPG backup: public keys, secret keys, ownertrust, revocation certs (existing + generate missing)
# Output: gpg-backup-YYYYmmdd-HHMMSS/ plus optional tar.gz

# --- Config ---
GPG_BIN="${GPG_BIN:-gpg}"
OUT_ROOT="${OUT_ROOT:-$PWD}"
MAKE_TARBALL="${MAKE_TARBALL:-1}"   # 1 = create tar.gz, 0 = no
ARMOR="${ARMOR:-1}"                 # 1 = ASCII armored exports, 0 = binary

timestamp="$(date +%Y%m%d-%H%M%S)"
outdir="${OUT_ROOT}/gpg-backup-${timestamp}"
mkdir -p "$outdir"

log() { printf '%s\n' "[$(date +%H:%M:%S)] $*"; }
die() { printf '%s\n' "ERROR: $*" >&2; exit 1; }

command -v "$GPG_BIN" >/dev/null 2>&1 || die "gpg not found (set GPG_BIN=/path/to/gpg)"

# Determine GNUPGHOME used by gpg (best-effort)
GNUPGHOME_DIR="${GNUPGHOME:-$HOME/.gnupg}"
revocs_dir="${GNUPGHOME_DIR}/openpgp-revocs.d"

log "Using gpg binary: $GPG_BIN"
log "Assuming GNUPGHOME: $GNUPGHOME_DIR"
log "Writing backup to: $outdir"

# --- 1) Export all public keys ---
log "Exporting all public keys..."
if [[ "$ARMOR" -eq 1 ]]; then
  "$GPG_BIN" --armor --export > "${outdir}/public-keys.asc"
else
  "$GPG_BIN" --export > "${outdir}/public-keys.gpg"
fi

# --- 2) Export all secret keys (includes subkeys) ---
log "Exporting all secret keys..."
if [[ "$ARMOR" -eq 1 ]]; then
  "$GPG_BIN" --armor --export-secret-keys > "${outdir}/secret-keys.asc"
else
  "$GPG_BIN" --export-secret-keys > "${outdir}/secret-keys.gpg"
fi

# --- 3) Export ownertrust ---
log "Exporting ownertrust..."
"$GPG_BIN" --export-ownertrust > "${outdir}/ownertrust.txt"

# --- 4) Export list of secret key fingerprints (for revocation cert generation) ---
log "Collecting secret key fingerprints..."
mapfile -t fps < <("$GPG_BIN" --list-secret-keys --with-colons --fingerprint 2>/dev/null \
  | awk -F: '$1=="fpr"{print $10}')

if [[ "${#fps[@]}" -eq 0 ]]; then
  log "No secret keys found. Skipping revocation cert generation."
else
  log "Found ${#fps[@]} secret key fingerprint(s)."
fi

# --- 5) Copy existing revocation certificates if present ---
mkdir -p "${outdir}/revocation-certs"
if [[ -d "$revocs_dir" ]]; then
  log "Copying existing revocation certs from: $revocs_dir"
  # Copy all .rev files (GnuPG typically stores revocation certs here)
  shopt -s nullglob
  for f in "$revocs_dir"/*; do
    cp -a "$f" "${outdir}/revocation-certs/" || true
  done
  shopt -u nullglob
else
  log "Revocation cert directory not found: $revocs_dir (this may be normal on some setups)"
fi

# --- 6) Generate missing revocation certs (non-interactive) ---
# gpg --gen-revoke is normally interactive; use --batch + --pinentry-mode loopback with a canned reason.
# This should work with modern GnuPG, but if your configuration forbids loopback pinentry, you may be prompted.
log "Generating missing revocation certs (best-effort, non-interactive)..."

for fp in "${fps[@]}"; do
  # Determine output name
  out_rev="${outdir}/revocation-certs/${fp}.rev.asc"

  # Skip if we already copied one with same fingerprint-like name
  if [[ -s "$out_rev" ]]; then
    log "Revocation cert already exists for $fp (skipping)"
    continue
  fi

  # Generate a revocation certificate
  # Note: This does NOT revoke the key; it only creates the certificate file.
  # Provide reason "0" (no reason specified) + a short description.
  # If gpg requires passphrase/pinentry, it may still prompt depending on your setup.
  "$GPG_BIN" --batch --yes --pinentry-mode loopback \
    --output "$out_rev" --gen-revoke "$fp" <<'EOF' || {
0
Generated by automated backup script
y
EOF

  if [[ -s "$out_rev" ]]; then
    log "Generated revocation cert: $out_rev"
  else
    log "Could not generate revocation cert for $fp (you may need interactive mode)"
    rm -f "$out_rev" || true
  fi
done

# --- 7) Save some metadata for auditing ---
log "Saving metadata..."
"$GPG_BIN" --version > "${outdir}/gpg-version.txt"
"$GPG_BIN" --list-keys --keyid-format LONG > "${outdir}/list-public-keys.txt"
"$GPG_BIN" --list-secret-keys --keyid-format LONG > "${outdir}/list-secret-keys.txt"

# --- 8) Permissions hardening (best-effort) ---
log "Setting restrictive permissions on backup directory..."
chmod -R go-rwx "$outdir" || true

# --- 9) Optional tarball ---
if [[ "$MAKE_TARBALL" -eq 1 ]]; then
  tarball="${outdir}.tar.gz"
  log "Creating tarball: $tarball"
  tar -czf "$tarball" -C "$OUT_ROOT" "$(basename "$outdir")"
  log "Done."
  log "Backup directory: $outdir"
  log "Tarball: $tarball"
else
  log "Done."
  log "Backup directory: $outdir"
fi

cat <<EOF

Restore commands (example):
  ${GPG_BIN} --import ${outdir}/secret-keys.$([[ "$ARMOR" -eq 1 ]] && echo asc || echo gpg)
  ${GPG_BIN} --import ${outdir}/public-keys.$([[ "$ARMOR" -eq 1 ]] && echo asc || echo gpg)
  ${GPG_BIN} --import-ownertrust ${outdir}/ownertrust.txt

Security note:
  Treat secret-keys.* and the tarball as highly sensitive. Store offline + encrypted.
EOF
